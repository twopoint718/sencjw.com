- date: 2012-08-22
  title: my "transparent web" talk
  postbody: |
    <iframe src="http://www.slideshare.net/slideshow/embed_code/14023703" width="427" height="356" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="http://www.slideshare.net/twopoint718/the-transparent-web-14023703" title="The Transparent Web: Bridging the Chasm in Web Development" target="_blank">The Transparent Web: Bridging the Chasm in Web Development</a> </strong> from <strong><a href="http://www.slideshare.net/twopoint718" target="_blank">twopoint718</a></strong> </div>

    Without much ado at all, here's my talk.  I'm covering the *real*
    basics of using both [Ur/Web](http://www.impredicative.com/ur/)
    and [Opa](http://opalang.org/).  I create a basic "Hello world"
    page in each and then I go on to write a little "comments"
    system.

- date: 2012-05-05
  title: my gpl talk
  postbody: |

    <div style="width:425px" id="__ss_12802829"> <strong style="display:block;margin:12px 0 4px"><a href="http://www.slideshare.net/twopoint718/once-upon-a-time-at-the-mit-ai-lab" title="Once Upon A Time At the MIT AI Lab" target="_blank">Once Upon A Time At the MIT AI Lab</a></strong> <iframe src="http://www.slideshare.net/slideshow/embed_code/12802829" width="425" height="355" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe> <div style="padding:5px 0 12px"> View more <a href="http://www.slideshare.net/" target="_blank">presentations</a> from <a href="http://www.slideshare.net/twopoint718" target="_blank">twopoint718</a></div></div>

    *note to the reader, my speaker notes are reproduced below and all run
    together. Also, the editing isn't top-notch.*

    **notes**

    First a warning, if you thought I was going to talk about software
    licenses, I’m not. Not really. I’m going to talk mostly about
    people. Ideas are one thing, they are the compiled results of
    processes that people go through. I want to decompile some ideas. I
    want to talk about that.

    To that end, let me tell you a story. Let’s go back to 1980, Richard
    Stallman is employed as a staff hacker at the MIT AI lab. This is the
    stuff of legend.

    The lab had recently been given a new prototype printer from XEROX
    PARC. This was ten times faster than the previous printer, finishing a
    20 minute job in 2 minutes and with more precise shapes to boot.  This
    was the same sort of tech that a decade hence would touch off the
    desktop publishing revolution. But back at the AI lab, the printer was
    becoming the source of more headache than anything else. Stallman and
    others would send jobs to the printer only to show up later to find
    that the job had jammed four pages in. This was a minor annoyance, but
    it was multiplied by everyone at the lab. Stallman thought, “why
    should I have to babysit this machine when I can code?”

    Stallman knew a way to attack this sort of problem. On a previous
    printer he had modified the source to insert some monitoring code in
    the printer driver.  Periodically, Stallman’s code would check to see
    that the printer was proceeding in its assigned job, if it had
    stalled, the program would alert whoever’s print job was
    affected. You’d get a message like: “The printer is jammed. Please fix
    it.” It wasn’t perfect, but it informed those most interested in the
    problem.

    The solution this time around would be similar. Stallman could grab
    his old code, tweak it for the new printer and voilá: jam
    notifications. So Stallman rolled up his sleeves, grabbed a coffee,
    and opened up the Xerox source code.

    If you see where I’m going here, you’ll probably see what’s coming
    next. There was no source code.  Stallman even spoke with the
    programmer that had worked on it and that programmer wasn’t allowed
    reveal the code to Stallman.

    This is the moment where something happens. This is where an insight
    strikes, the apple falls on your head, the disparate pieces line up
    and you need to jump out of the tub and tell the world. Stallman
    decided, at that moment, that some fundamental wrong had been done:
    the wrong of not being allowed to help your neighbor by telling him
    how code works., This brings me to the main point of this talk. This
    is the thing that, even if everything else you hear is mangled or
    forgotten, I want to come through unchanged: RMS believes that
    software has moral implications, the choice of what kind of SOFTWARE
    you want is a choice about what kind of WORLD you want.

    Note all the things that I didn’t say. It isn’t about what is
    technically superior. It isn’t about what is good for being able to
    sell. It isn’t about what the legal department says. It has no bearing
    on what various companies will tell you to be worried about. It isn’t
    about being good for playing games, or having flash support. It is
    nothing more and nothing less than a philosophical stance. You can
    agree with it, or disagree with it in exactly the same way as you
    would argue about Plato’s Forms.

    I feel like this is the key misunderstanding in discussions
    surrounding the GPL and Free software. I’m taking a philosophical, an
    ethical, and maybe a moral stance. I haven’t brought anything else
    into it. Often, when I see discussions about software licenses, I feel
    like people are talking past one another from the very first sentence.

    It is profoundly nonsensical to compare something like “justice” to
    something like a wrench., Philosophers begin by defining words,
    because if they don’t, we’ll get so mired in the muck of argument that
    no points are made, no progress is made.

    The word “free” is a good place to start. Free can be taken to mean
    “no cost” but it can also be taken to mean “freedom”. This is sort of
    a fine point to make, but I think it could lead to lots of confusion.

    Free software has to do with the “freedom” part. There are lots of
    really good objections at this point. The one that I have anticipated
    is “freedom for whom?” And that’s the core of the so-called permissive
    divide in the broader category of “open” software. The permissive
    people would respond to the “freedom for whom” question with something
    like “certainly not for me, you say I *must* share changes, that’s
    pretty restrictive.” And the answer to “freedom for whom?” that I want
    to present here is...

    Well, that’s the rest of my talk., The GPL is a really a more general
    case of the Emacs license.

    Now Emacs has a pretty storied history, wikipedia dates it back to the
    mid seventies, well before GNU or Emacs-as-GNU-project. But by the
    time of the release of Emacs 15, there was a sort of proto-GPL license
    attached. It served to give “users the right to make and distribute
    copies” and “the right to make modified versions, but not the right to
    claim sole ownership of those modified versions”. It was moving in a
    similar direction, but it was not as legalistically formal as the
    eventual GNU project would need it to be.

    Stallman’s intellectual property attorney at the time viewed the GNU
    Emacs License pretty much as a simple contract, although one that
    stipulated a rather odd price. Rather than money, the license cost
    access to any changes. Users would have to share modified versions of
    the software. The attorney remarked: "I think asking other people to
    accept the price was, if not unique, highly unusual at that time"

    In 1989 a 1.0 version of the GPL had emerged. The preamble read:

    > The General Public License is designed to make sure that you have the
    > freedom to give away or sell copies of free software, that you receive
    > source code or can get it if you want it, that you can change the
    > software or use pieces of it in new free programs; and that you know
    > you can do these things.
    >
    > To protect your rights, we need to make restrictions that forbid
    > anyone to deny you these rights or to ask you to surrender the
    > rights. These restrictions translate to certain responsibilities for
    > you if you distribute copies of the software, or if you modify it.

    one notable change was that users were no longer required to share
    changes. You could make private in-house tweaks to the software
    without being forced to share these changes back to the community.  ,
    License agreements are not usually characterized by what they *give*
    you, rather, as we scan ever longer End User License Agreements, or
    plow through revision 271 of Facebook’s new much-better-we-assure-you
    privacy policy, we are looking for things that they are taking from
    us.

    The GPL, in essence, tries to codify a very idealistic hacker
    ethic. It is for tinkering, changing, breaking, reassembling, and
    passing it on to your friend. It is software as mix-tape.

    The main things that the GPL gives you are broken down into four
    parts, aka the “four freedoms”, Zero: You’re allowed to do what you
    want with the software. An author can’t proscribe the software’s use
    for something that they don’t approve of. This is pretty profound, I
    think.

    one: if you are going to be able to do this, you’ll need the source
    code. You’ll also need whatever is required to actually end up with a
    working program. This can be a point of contention. A corner case of
    this is in embedded systems such as set-top boxes where the code may
    be GPL, busybox is a common example, but you can’t actually change the
    code due to things like code signing., two: I think it is interesting
    that two emphasizes the goal of the redistribution. It isn’t just for
    fun or for copying’s sake, it is because we view software as something
    that can help people.

    freedom three, the final freedom. You’ll also need access to the
    source code to realize this one. You are allowed to make public
    changes to the code. The difference with freedom one is that you’re
    allowed to do this out in the open, rather than just in private and
    for your own reasons. You can fork. You can contribute back.

    lurking in freedom three is also the core of my argument, which I
    promise I’m getting to really soon., I’m going to try and dispel a
    common myth about the GPL, one I’ve heard a lot. The general gist is
    that “the GPL is to copyright as anarchy is to government.” Something
    that is opposed to the very notion of it. This is where people get the
    idea that any business built on such shifting sand of self-destruction
    must be flawed in some way.

    Opposition to copyright is an interesting subject, there’s lots of
    good debate. But it doesn’t really have anything to do with the
    GPL. The GPL has staked its efficacy IN copyright.

    Far from being some sort of anti-copyright construct, the GPL’s
    EXISTENCE depends on copyright, if you didn’t have copyright, you
    couldn’t have the GPL (or lots of other stuff). You wouldn’t get any
    say in what people do with your stuff... but that’s another discussion
    entirely!

    So for the rest of the talk, consider copyright to be a constant
    underpinning, a foundational necessity for everything else we’re
    talking about. It’s just that we’re going to use it for something that
    it wasn’t intended: we’re hacking it., BAM: flip it

    copyleft: pay it forward.

    As Stallman said: “see [the GPL] as a form of intellectual jujitsu,
    using the legal system that software hoarders have set up against
    them”, he actually lifted this from a similar sticker from a sci-fi
    convention which read: "Copyleft (L), All Rights Reversed.”, And this
    brings me around to what my thinking on the GPL is. I guess I’m kinda
    surprised by all the emphasis on virulence these days. The metaphor is
    broken. Metaphors are broken--but that’s another talk.

    Casting aside any metaphors, the GPL is an *inductive license*. This is a
    term that I made up but I think it describes the nature of the GPL much
    better than saying that it is viral.

    An initial case is established. You have the four freedoms: the
    freedom to run, freedom to change, freedom to redistribute, and the
    freedom to share those changes.

    But for it to really be Free software, the person *receiving* the
    software must have these freedoms. So it is not good enough for us to
    leave it here. We only have the base case for a software license. We
    have to prove the general case, not me or you, but person N+1., So the
    person who’s freedom we’re talking about is person N+1, the inductive
    person.

    This idea is the essential difference between being permissive
    software and being free software. Free software describes the case of
    that person N+1, inductively. It raises the “freedom for whom?”
    question and answers it with “the inductive person”.

    So I’ll leave where, approximately, I started with a definition:

    The word “induction” is the practice of deriving general laws from
    specific cases, it arises from a root word meaning “leading to” or
    “hypothetical”. Free software asks us to consider this hypothetical
    person on the assumption that it could someday be anyone, indeed
    everyone.

- date: 2011-12-27
  title: secret santa
  postbody: |

    While I was sitting around and eating a ton of Christmas food, I
    got to thinking about the [Secret
    Santa](http://en.wikipedia.org/wiki/Secret_Santa) problem.  In its
    most basic form, this is the same as something called a
    [derangement](http://mathworld.wolfram.com/Derangement.html).  I
    mention it just because I think the name is cool, the concept is
    super simple, a *derangement* is a permutation of the elements of
    a list such that no element stays in the same place:

        [1, 2, 3] would have a derangement:
        [2, 3, 1]

    notice that each element has moved.  So this pertains to secret
    santas because if you are just not allowed to chose yourself then
    a derangement (like
    [this](http://hackage.haskell.org/package/derangement)) is all
    that you'd need, it would be a valid secret santa!

        > zip [1, 2, 3] (derangement [1, 2, 3])
        [(1,2),(2,3),(3,1)]

    cool! person 1 gives to person 2, person 2 gives to person 3, and
    person 3 gives to person 1.

    As my family could tell you, I thought that I could do better (in
    keeping with my motto "if it ain't broke, fix it until it is").
    Wouldn't it be cool if in additon to just forbidding the case
    where you pick your own name (reflexive), you also can provide two
    more lists. One is a list of pairings which are *disallowed* and
    the second is a list of pairings which are to be *discouraged*
    (less likely).

    I've implemented almost what I just described.  In the code below,
    I don't actually make a selection from some distribution where
    discouraged selections are less likely.  Instead, I've added a
    `bestSantas` function that allows you to limit yourself to
    selections that are under a certain amount of *badness* (a
    selection has 1 point of badness for each discouraged pairing that
    it includes).  I hadn't decided how I wanted to select from among
    differing levels of badness yet.  But anyway, enjoy!

    <script src="https://gist.github.com/1525233.js"></script>

- date: 2011-12-15
  title: sopa hearings
  postbody: >

    These SOPA hearings are beyond awful.  The fact that the hearings, at least
    as I have found them at 6pm CST, are about who has standing to sue in the
    US, nothing more.  This feels like a group of people standing around trying
    to decide to roast hotdogs or marshmallows as the [Library of
    Alexandria](http://en.wikipedia.org/wiki/Library_of_Alexandria) burns.


    [This
    letter](https://www.eff.org/deeplinks/2011/12/internet-inventors-warn-against-sopa-and-pipa),
    which carries the signatures of many the designers and builders of the
    Internet (TCP/IP, BIND, DNS, HTTP, MIME, etc.), clearly lays out the damage
    that this bill would cause.


    What I find infuriating about the discussions that are happening right now
    regarding SOPA, is that the committee members are so glaringly ignorant of
    the Internet.  There is no discussion of how it would work with DNS, what
    burden that would put on hosting companies, schools, organizations, etc.
    In short, they don't appear to know how the Internet works.


    I cannot help but worry that there are influencers promoting this bill who
    have a very narrow interest in the Internet.  They see it as an economic
    threat to an old business model (movies, music) and it must be turned into
    a safe and effective mechanism to secure an income stream in the future.


- date: 2011-09-24
  title: "strangeloop 2011 notes"
  postbody: >

    I got back from [Strangeloop 2011](https://thestrangeloop.com/)
    just this week and wanted to cover some of the interesting points
    from this *really* fascinating conference (it is on my *must go*
    list from now on)!


    It was incredibly difficult to get to all the talks that I wanted
    to see because the conference was "seven talks wide" at most
    points.  A common theme emerged where, as I finished up a talk in
    one room, I would see the stream of tweets start rolling in about
    some incredible talk that I had just missed; I can't wait for
    those videos.


    Here's my recap of the stuff that I went to:


    **Sunday (workshop day)**

     * *Haskell: Functional Programming, Solid Code, Big Data* with
       Bryan O'Sullivan - this was a really nice intro to Haskell for
       someone that hadn't ever seen it before.  I've worked through
       about half of the "Real World Haskell" book so a lot of this
       was not new.  But it was great to see one of the authors
       explain some points himself.  There was also some interesting
       comments from [Gerald
       Sussman](http://en.wikipedia.org/wiki/Gerald_Jay_Sussman) about
       how haskell is the "most advanced of the obsolete languages"
       (more on that later).


    **Monday (first day of conference)**

     * *Category Theory, Monads, and Duality in (Big) Data* with Erik
        Meijer - This was a really cool opening keynote where Erik
        Meijer launched the new term *CoSQL* instead of *NoSQL* by
        showing how the two concepts are
        [duals](http://en.wikipedia.org/wiki/Dual_(mathematics)) of
        one another (in the mathematical, category theory sense). This
        proved to be something of an overarching theme of the
        conference, things being different but mirrored versions of
        the same thing. see: [A co-Relational Model of Data for Large
        Shared Data
        Banks](http://queue.acm.org/detail.cfm?id=1961297).

     * *[I skipped this timeslot because I was on the [hallway
        track](http://blog.hallwaytrack.org/articles/2006/04/27/the-hallway-track-blog)
        listening to Erik Meijer talk about static typing with some
        scala folks; very interesting!]*

     * *An Introduction to Doctor Who (and Neo4j)* with Ian Robinson -
        I have to admit, I got sucked in because I'm a huge Doctor Who
        fan, but I *had* heard of graph databases before and Neo4j
        looked to be a really interesting one. In particular, I wanted
        to see if this could be used from Clojure (yes:
        [borneo](http://github.com/wagjo/borneo) and
        [clojure-neo4j](https://github.com/mattrepl/clojure-neo4j)). The
        talk concerend building a very complicated network of the
        relationships between several Doctor Who props (Daleks!) over
        time. It was pretty easy to see how these mapped nicely to
        nodes with arcs between them.

     * *Skynet: A Scalable, Distributed Service Mesh in Go* with Brian
        Ketelsen - this was a cool talk about a lightweight framework
        written in [go](http://golang.org/) for writing distributed
        applications that are highly resilient. It uses
        [Doozer](https://github.com/ha/doozerd) for data storage
        (though it didn't in this talk).

     * *Parser Combinators: How to Parse (nearly) Anything* with Nate
        Young - This talk gave examples of writing parser combinators
        (where a *parser* here means a function that can consume a
        little input, and then returns another function that consumes
        input after it). The idea is to chain these parsers together
        with *combinators* (higher-order functions which take parsers
        and operate on them, like "oneOrMore" etc.).  This talk
        reminded me of Bryan O'Sullivan's funny phrase about how
        haskell's ">>=" operator (read "bind") is written in "moon
        language".

     * *Getting Truth Out of the DOM* with Yehuda Katz - This was a
        talk about the [SproutCore](http://www.sproutcore.com/)
        framework. Katz had a lot of insight about how to keep the
        browser interaction abstract and event-based rather than
        mucking about (and then being mired) in the DOM.

     * *We Don't Really Know How to Compute!* with Gerald Sussman -
        This was a mind-blowing keynote. In fact, I had to develop a
        new unit of measure, the *Eureka*, which denotes having one's
        mind blown once per minute.  I think that in the 50-some
        minute talk that Sussman gave, I may have had more than about
        50 mind-blowing thoughts. At one point Sussman asked how much
        time he had left and someone from the audience yelled out "who
        cares?", which was pretty much the feeling in the room.

        Sussman started out the talk with a picture of a [Kanizsa
        Triangle](http://en.wikipedia.org/wiki/Illusory_contours) and
        mentioned that the brain can infer that there is a hidden
        triangle in just about 100 ms which is a few tens of "cycles"
        for the brain.  With a computer, we don't know how to even
        begin to solve this recognition problem in that few of cycles;
        *we don't really know how to compute*. Sussman's idea (which I
        can't do justice to here), was that computing as we know it
        has to and will change in the near future. Computing will
        become massively distributed ("ambient", but this term is from
        a later talk) and in disparate nodes that must collaborate to
        arrive at answers.

        His
        [example](http://groups.csail.mit.edu/mac/projects/amorphous/Robust/),
        a *Propagator* was a program that can integrate more annd more
        data while keeping track of the provenance of that data. Or
        another way an "independent stateless machine connecting
        stateful cells". Amazing!


    **Tuesday (second day of conference)**

     * *Embedding Ruby and RubyGems Over RedBridge* with Yoko Harada -
       This didn't make that much sense to me until coworker (@devn)
       started doing some cool stuff with using ruby gems from clojure.

     * *Event Driven Programming in Clojure* with Zach Tellman - This
       was a really cool talk.  It looked to me to be an
       implementation of go-style concurrency (channels) in clojure.
       There was also a macro that would analyze data dependencies and
       do the correct async calls. The projects are called
       [Lamina](http://github.com/ztellman/lamina) and
       [Aleph](http://github.com/ztellman/aleph) and they're one of
       those things that I want to find a project on which to use
       them.

     * *Teaching Code Literacy* with Sarah Allen - This was a talk
       about how to give kids the opportunity to learn about
       programming at an early age (Allen says that programming is one
       of those things that you don't know if you'll like it until
       you've tried it.)  She also had found that the ages that
       programming should be introduced is 5th-6th grade; earlier than
       I thought!

     * *Post-PC Computing is not a Vision* with Allen Wirfs-Brock -
       This talk started with a breakdown of the eras of computing.
       First was a "coporate" era, then a "personal" era, and now we
       are entering the "ambient" era.  Each era is defined by what
       ends computing resources are put toward.  In the coporate era
       computing was used to solve problems that businesses had, then
       computing became more available generally, and finally it is
       becoming ubiquitous.  This talk also covered the history of the
       browser and how it is, and will be, the platform for the
       forseeable future.

     * *Simple Made Easy* with Rich Hickey - Rich's talk was an
       argument for disentangling computing.  It started with
       separating the notions of "simple", "complex", and "easy".
       Easy is a subjective thing, things that I find easy you may
       not.  Simple is objective, it derives from the notion of "a
       single fold".  Complex is just the opposite, it is "woven or
       braided".  We must avoid adding complexity to our software, or
       as Rich put it, we must not "complect" it ("to interweave or
       entwine").  Humans have a finite (and very limited) ability to
       handle many factors simultaneously, and so to have any hope of
       working with difficult problems, we must be rigorous in working
       toward simplicity.


       Rich had a few words for TDD in his talk, and I think these
       were widely misinterpreted.  His point was simply that tests
       have a cost and a thoughtless devotion to them will risk
       underestimating that cost.  I think a lot of people took that
       to mean "you shouldn't test" or that "tests are worthless", but
       I think he was just pointing out that they're not free.  He
       introduced the term "guardrail programming" for a style that
       just bounces between the guardrails rather than proceeds to a
       destination by steering.


       This talk drew a standing ovation from the crowd, including, I
       hear, Gerald Sussman.  I'll be looking for it on video when it
       comes out.


    Strangeloop 2011+N is definitely on my must-attend list.  The
    people that I met (which could be another couple of blog posts)
    were worth the admission all by themselves.  The talks were
    fascinating and gave me a ton to read up on.  The conference felt
    like it was well-run and organized.  St. Louis was a cool city to
    hang out in (I wish we had the same open-container law in
    Madison!).  I can't wait for next year.


- date: 2011-08-16
  title: Madison Ruby Conference
  postbody: >
    I'm going to be attending the [Madison Ruby
    Conference](http://madisonruby.org) this Friday and Saturday.  I
    must confess that I'm not a Ruby-ista (does this reveal my
    *pythonista* heritage?) by training but I'm really excited to go
    and see who attends, chat with smart tech-folk, and generally have
    a good nerd-time yakking about code.  Plus, it couldn't hurt to
    see a little ruby code and see what all the fuss is about.  I'm
    not going to confine myself to: C, Java, Python, Lisp, Haskell,
    and shell. Conference Ahoy.

- date: 2011-07-03
  title: Social Networking
  postbody: >
    *Google+ is another Facebook*.  It may be nice but we should all
    remember that it is basically the same thing.  That may be a
    positive or a negative for you, but the same conversation that
    we've been having about Facebook applies to Google+.  If we want
    to network with people, perhaps it is worthwhile to consider
    existing tools.  Blogs for general sharing (blogs that live on
    your own server!), email for 1-to-1 correspondence, IRC for chat
    and so on.  You don't need a third party to mediate your
    relationships.


    Enjoy the [XKCD on the topic](http://xkcd.com/918/).

- date: 2011-06-21
  title: Code Crawl
  postbody: >
    A *code crawl* is an event that's a mix of a
    [hackathon](http://en.wikipedia.org/wiki/Hackathon) and a [pub
    crawl](http://en.wikipedia.org/wiki/Pub_crawl).  Here's how it
    works:


    Interested parties grab their laptops or, I suppose, lug their
    desktops, out to the bars.  Everybody orders a drink or two and
    hacks on code for around an hour.  The group gathers around a big
    table if the bar has it, or keeps in quasi-remote contact from the
    bar's far-flung corners via IRC or the like.  If the atmosphere
    allows it, it's fun for participants to just yell "try it now" or
    "pull from my repo" across the room.  Maybe they'll get puzzled
    stares from other patrons.  They should just explain that it's a
    code crawl and everyone is programming!  When they reach a good
    *break point* (ha), or just after an hour or two, everybody closes
    out their tabs (or the single mondo-tab!) and heads off to the
    next stop on the crawl.


    Groups can do something fun when they think they've collectively
    hit the [Ballmer Peak](http://xkcd.com/323/).  Of course, it's
    probably then a good time to wrap up the crawl!

- date: 2011-05-27
  title: First Post
  postbody: >
    First post.  That's what's the best about reformatting a blog.  It
    always seems to generate at least one extra post.  It's weird how
    blogging software does that.

- date: 2011-05-01
  title: Hackerspace Show on Wisconsin Public Radio
  postbody: >
    [Larry Meiller did a show
    about](http://www.wpr.org/webcasting/audioarchives_display.cfm?Code=mlr&StartRow=1&keyword=makerspace&highlight=on&x=0&y=0)
    (maker|hacker)spaces in Wisconsin. Sector67 is mentioned.

- date: 2011-03-02
  title: "Don't zip, bundle(1)"
  postbody: >
    I've been playing around with Plan 9 from Bell Labs a bunch
    lately. It takes the Unix idea that everything should have a
    file-like interface and runs with that to its logical (and
    surprisingly useful) extreme. It seems like a system that hangs
    together really well and has the feeling that it was actually
    designed, rather than grown. But that's enough about that. What I
    wanted to mention was a script, bundle(1), that I found to be
    really useful. So, use the source, Luke!, and then I'll say
    something about it:

        #!/bin/sh
        echo '# To unbundle, run this file'
        for i
        do
            echo "echo $i"
            echo "sed 's/.//' >$i <<'//GO.SYSIN DD $i'"
            sed "s/^/-/" $i
            echo "//GO.SYSIN DD $i"
        done

    Cool huh? It's kinda meta but here's what it does: when you run it
    like bundle file1 file2 > regen.sh it outputs a script that when
    run will recreate file1 and file2. It does this with a few
    applications of sed. Using file1 and file2 as examples, say I
    have file1's contents:

        hello

    and file2 is:

        world!

    after running bundle with these two files the contents of regen.sh
    will look like this:

        # To unbundle, run this file
        echo file1
        sed 's/.//' > file1 <<'//GO.SYSIN DD file1'
        -hello
        //GO.SYSIN DD file1
        echo file2
        sed 's/.//' > file2 <<'//GO.SYSIN DD file2'
        -world!
        //GO.SYSIN DD file2

    so, if you run this file, it prints "file1" and "file2" to the
    terminal, but then writes "hello" and "world" to file1 and file2,
    respectively (after having stripped the "-" off of each line using
    sed).  So this is a neat little way to package up a bunch of
    text-ish files into a single "self-expanding" package.


- date: 2011-03-20
  title: Learning to type on the Twiddler keyboard
  postbody: >
    I recently got a twiddler chorded keyboard (I love it).  My two
    main goals with it are to be able to use it while doing things
    like giving talks, because it is like having one of those
    presentation clickers yet at the same time being able to
    competently type with it. And the second goal is to use it on my
    smartphone as a better alternative to the on-screen keyboard. I
    just want to make a little aside on the second goal.  It's not
    totally clear to me how to use an external USB keyboard with
    Android (though I have some leads) but things look generally
    promising.


    Either use, of course, assumes that I can type on the crazy
    thing.  I'm one of those people that find it fun to try and
    re-wire my brain to do new things and I figure that if I switched
    to dvorak (and have been using it for about 10 years) that I can
    tackle this thing! I decided to do some drills with the Twiddler
    so that I get to the point where I can use it for day-to-day
    stuff, from then on it'll bootstrap itself through frequent
    use.  That, by the way, was roughly my technique for learning
    dvorak back in the day

     1. Print out the layout and tape it up at eye-level, this breaks
        you of the habit of looking at the keys (they won't help you
        if you remap the keyboard in software)
     2. Do simple drills of the home row (this is great on Dvorak
        because you can form TONS of words)
     3. Expand the drills to less frequently used letters and
        characters
     4. Now that you can type all words, even if you are slow, get on
        IM or IRC in a low-traffic channel that you would like to
        participate in, and just converse. This will provide both
        motivation and practice without the feeling of banging your
        head against the wall.
     5. Do this daily or almost-daily for about 4-8 weeks (that's
        about how long it took me to match and then exceed my QWERTY
        speed)

    To deal with steps 2 and 3 on the twiddler, I wrote this
    short python script that pulls words out out /usr/share/dict/words
    that can be typed without any chord (open), using the first chord
    key (1st or "L"), and finally the second chord key (2nd or
    "M").  I don't have the third chord key on here because using just
    the first and second is sufficient for all letters.  Here's the
    script:

        import random

        def all_from(target_list, input_list):
            for c in input_list:
                if not c in target_list:
                    return False
            return True

        def first_set(input_word):
            return all_from("abcdefghABCDEFGH", input_word)

        def second_set(input_word):
            return all_from("ijklmnopqIJKLMNOPQ", input_word)

        def third_set(input_word):
            return all_from("rstuvwxyzRSTUVWXYZ", input_word)

        def fourth_set(input_word):
            return all_from(".,;'\"?!-", input_word)

        def search_words(words, key_set=first_set):
            out = []
            for word in words:
                if key_set(word) and len(word) > 1:
                    out.append(word)
            return out

        if __name__ == "__main__":
            get_words = 10
            fname = "/usr/share/dict/words"
            wordlist = open(fname, "r").read().split("\n")

            first = search_words(wordlist, first_set)
            second = search_words(wordlist, second_set)
            third = search_words(wordlist, third_set)
            #fourth = search_words(wordlist, fourth_set) # need wordlist w/ punct.

            print "open: ", " ".join(random.sample(first, get_words))
            print "1st:  ", " ".join(random.sample(second, get_words))
            print "2nd:  ", " ".join(random.sample(third, get_words))
            #print "3rd:  ", " ".join(random.sample(fourth, get_words))

- date: 2010-12-05
  title: unfill-paragraph (only Emacs nerds need apply)
  postbody: >
    I usually keep plain text at a nice and tidy 72 columns (give or
    take, but certainly under 80!).  But there are times when it is
    necessary to have code that will be folded (word-wrapped) by the
    end user.  Think of those text boxes on websites where the result
    is going to be displayed on some website in a totally unformatted
    way. In this case you want the text to be one long line per
    paragraph with a blank line separating each. That way, the text is
    as wide as the browser window or otherwise follows user
    preferences (see
    <http://www.mozilla.org/unix/customizing.html#usercss> for how to
    do this in Firefox). Since I'm always hitting M-q in Emacs, my
    code's always formatted at 72ish columns. The following bit of
    Emacs Lisp lets you unfill-lines, that is it strips out newline
    characters within a paragraph.

        ;; Stefan Monnier <foo at acm.org>. It is the opposite of fill-paragraph
        ;; Takes a multi-line paragraph and makes it into a single line of text.

        (defun unfill-paragraph ()
            (interactive)
            (let ((fill-column (point-max)))
            (fill-paragraph nil)))

        (global-set-key (kbd "C-c M-q") 'unfill-paragraph)

- date: 2010-11-16
  title: Maine
  postbody: >
    <div class="gallery"><a href="img/DSC-6981-SMALL.jpg"><img
      alt="Maine Seashore"
      src="img/DSC-6981-SMALL-1024x680.jpg"></a></div>

- date: 2010-11-13
  title: Remembrance of Blogs Past
  postbody: >
    <div class="img"><img src="img/hypnotoad_clockscope.jpg"
    alt="hypnotoad"></div>
    Yikes, it always seems to come to this. I find myself with a blank
    directory or database (it depends on the blog) that needs to be
    filled up with stuff that I write. And as is the requirement, I go
    and start filling it up with data.


    I can pardon you for missing the blog that previously inhabited
    this domain name. Its short run was punctuated by frequent DNS
    issues, the blog equivalent of being deprived of oxygen. It was
    also overly fussy in its implementation so there was really no
    chance that Sarah would ever put words on the site (the same is
    true for me).


    I switched over to WordPress after seeing some pretty impressive
    examples of what it does nowadays.


    So as has become my custom, I'll link back to other sites that
    I've also written.

     * [chrisblog](chrisblog.zip) (Blogger, zip file)
     * [Nerd Blog](http://twopoint718.posterous.com/) (Posterous)
     * [sencjw_blog](sencjw_blog.zip) (zip file)
