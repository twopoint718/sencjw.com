- date: 2012-12-15
  title: sopa hearings
  postbody: >

    These SOPA hearings are beyond awful.  The fact that the hearings, at least
    as I have found them at 6pm CST, are about who has standing to sue in the
    US, nothing more.  This feels like a group of people standing around trying
    to decide to roast hotdogs or marshmallows as the [Library of
    Alexandria](http://en.wikipedia.org/wiki/Library_of_Alexandria) burns.


    [This
    letter](https://www.eff.org/deeplinks/2011/12/internet-inventors-warn-against-sopa-and-pipa),
    which carries the signatures of many the designers and builders of the
    Internet (TCP/IP, BIND, DNS, HTTP, MIME, etc.), clearly lays out the damage
    that this bill would cause.


    What I find infuriating about the discussions that are happening right now
    regarding SOPA, is that the committee members are so glaringly ignorant of
    the Internet.  There is no discussion of how it would work with DNS, what
    burden that would put on hosting companies, schools, organizations, etc.
    In short, they don't appear to know how the Internet works.


    I cannot help but worry that there are influencers promoting this bill who
    have a very narrow interest in the Internet.  They see it as an economic
    threat to an old business model (movies, music) and it must be turned into
    a safe and effective mechanism to secure an income stream in the future.


- date: 2011-09-24
  title: "strangeloop 2011 notes"
  postbody: >

    I got back from [Strangeloop 2011](https://thestrangeloop.com/)
    just this week and wanted to cover some of the interesting points
    from this *really* fascinating conference (it is on my *must go*
    list from now on)!


    It was incredibly difficult to get to all the talks that I wanted
    to see because the conference was "seven talks wide" at most
    points.  A common theme emerged where, as I finished up a talk in
    one room, I would see the stream of tweets start rolling in about
    some incredible talk that I had just missed; I can't wait for
    those videos.


    Here's my recap of the stuff that I went to:


    **Sunday (workshop day)**

     * *Haskell: Functional Programming, Solid Code, Big Data* with
       Bryan O'Sullivan - this was a really nice intro to Haskell for
       someone that hadn't ever seen it before.  I've worked through
       about half of the "Real World Haskell" book so a lot of this
       was not new.  But it was great to see one of the authors
       explain some points himself.  There was also some interesting
       comments from [Gerald
       Sussman](http://en.wikipedia.org/wiki/Gerald_Jay_Sussman) about
       how haskell is the "most advanced of the obsolete languages"
       (more on that later).


    **Monday (first day of conference)**

     * *Category Theory, Monads, and Duality in (Big) Data* with Erik
        Meijer - This was a really cool opening keynote where Erik
        Meijer launched the new term *CoSQL* instead of *NoSQL* by
        showing how the two concepts are
        [duals](http://en.wikipedia.org/wiki/Dual_(mathematics)) of
        one another (in the mathematical, category theory sense). This
        proved to be something of an overarching theme of the
        conference, things being different but mirrored versions of
        the same thing. see: [A co-Relational Model of Data for Large
        Shared Data
        Banks](http://queue.acm.org/detail.cfm?id=1961297).

     * *[I skipped this timeslot because I was on the [hallway
        track](http://blog.hallwaytrack.org/articles/2006/04/27/the-hallway-track-blog)
        listening to Erik Meijer talk about static typing with some
        scala folks; very interesting!]*

     * *An Introduction to Doctor Who (and Neo4j)* with Ian Robinson -
        I have to admit, I got sucked in because I'm a huge Doctor Who
        fan, but I *had* heard of graph databases before and Neo4j
        looked to be a really interesting one. In particular, I wanted
        to see if this could be used from Clojure (yes:
        [borneo](http://github.com/wagjo/borneo) and
        [clojure-neo4j](https://github.com/mattrepl/clojure-neo4j)). The
        talk concerend building a very complicated network of the
        relationships between several Doctor Who props (Daleks!) over
        time. It was pretty easy to see how these mapped nicely to
        nodes with arcs between them.

     * *Skynet: A Scalable, Distributed Service Mesh in Go* with Brian
        Ketelsen - this was a cool talk about a lightweight framework
        written in [go](http://golang.org/) for writing distributed
        applications that are highly resilient. It uses
        [Doozer](https://github.com/ha/doozerd) for data storage
        (though it didn't in this talk).

     * *Parser Combinators: How to Parse (nearly) Anything* with Nate
        Young - This talk gave examples of writing parser combinators
        (where a *parser* here means a function that can consume a
        little input, and then returns another function that consumes
        input after it). The idea is to chain these parsers together
        with *combinators* (higher-order functions which take parsers
        and operate on them, like "oneOrMore" etc.).  This talk
        reminded me of Bryan O'Sullivan's funny phrase about how
        haskell's ">>=" operator (read "bind") is written in "moon
        language".

     * *Getting Truth Out of the DOM* with Yehuda Katz - This was a
        talk about the [SproutCore](http://www.sproutcore.com/)
        framework. Katz had a lot of insight about how to keep the
        browser interaction abstract and event-based rather than
        mucking about (and then being mired) in the DOM.

     * *We Don't Really Know How to Compute!* with Gerald Sussman -
        This was a mind-blowing keynote. In fact, I had to develop a
        new unit of measure, the *Eureka*, which denotes having one's
        mind blown once per minute.  I think that in the 50-some
        minute talk that Sussman gave, I may have had more than about
        50 mind-blowing thoughts. At one point Sussman asked how much
        time he had left and someone from the audience yelled out "who
        cares?", which was pretty much the feeling in the room.

        Sussman started out the talk with a picture of a [Kanizsa
        Triangle](http://en.wikipedia.org/wiki/Illusory_contours) and
        mentioned that the brain can infer that there is a hidden
        triangle in just about 100 ms which is a few tens of "cycles"
        for the brain.  With a computer, we don't know how to even
        begin to solve this recognition problem in that few of cycles;
        *we don't really know how to compute*. Sussman's idea (which I
        can't do justice to here), was that computing as we know it
        has to and will change in the near future. Computing will
        become massively distributed ("ambient", but this term is from
        a later talk) and in disparate nodes that must collaborate to
        arrive at answers.

        His
        [example](http://groups.csail.mit.edu/mac/projects/amorphous/Robust/),
        a *Propagator* was a program that can integrate more annd more
        data while keeping track of the provenance of that data. Or
        another way an "independent stateless machine connecting
        stateful cells". Amazing!


    **Tuesday (second day of conference)**

     * *Embedding Ruby and RubyGems Over RedBridge* with Yoko Harada -
       This didn't make that much sense to me until coworker (@devn)
       started doing some cool stuff with using ruby gems from clojure.

     * *Event Driven Programming in Clojure* with Zach Tellman - This
       was a really cool talk.  It looked to me to be an
       implementation of go-style concurrency (channels) in clojure.
       There was also a macro that would analyze data dependencies and
       do the correct async calls. The projects are called
       [Lamina](http://github.com/ztellman/lamina) and
       [Aleph](http://github.com/ztellman/aleph) and they're one of
       those things that I want to find a project on which to use
       them.

     * *Teaching Code Literacy* with Sarah Allen - This was a talk
       about how to give kids the opportunity to learn about
       programming at an early age (Allen says that programming is one
       of those things that you don't know if you'll like it until
       you've tried it.)  She also had found that the ages that
       programming should be introduced is 5th-6th grade; earlier than
       I thought!

     * *Post-PC Computing is not a Vision* with Allen Wirfs-Brock -
       This talk started with a breakdown of the eras of computing.
       First was a "coporate" era, then a "personal" era, and now we
       are entering the "ambient" era.  Each era is defined by what
       ends computing resources are put toward.  In the coporate era
       computing was used to solve problems that businesses had, then
       computing became more available generally, and finally it is
       becoming ubiquitous.  This talk also covered the history of the
       browser and how it is, and will be, the platform for the
       forseeable future.

     * *Simple Made Easy* with Rich Hickey - Rich's talk was an
       argument for disentangling computing.  It started with
       separating the notions of "simple", "complex", and "easy".
       Easy is a subjective thing, things that I find easy you may
       not.  Simple is objective, it derives from the notion of "a
       single fold".  Complex is just the opposite, it is "woven or
       braided".  We must avoid adding complexity to our software, or
       as Rich put it, we must not "complect" it ("to interweave or
       entwine").  Humans have a finite (and very limited) ability to
       handle many factors simultaneously, and so to have any hope of
       working with difficult problems, we must be rigorous in working
       toward simplicity.

       
       Rich had a few words for TDD in his talk, and I think these
       were widely misinterpreted.  His point was simply that tests
       have a cost and a thoughtless devotion to them will risk
       underestimating that cost.  I think a lot of people took that
       to mean "you shouldn't test" or that "tests are worthless", but
       I think he was just pointing out that they're not free.  He
       introduced the term "guardrail programming" for a style that
       just bounces between the guardrails rather than proceeds to a
       destination by steering.

       
       This talk drew a standing ovation from the crowd, including, I
       hear, Gerald Sussman.  I'll be looking for it on video when it
       comes out.


    Strangeloop 2011+N is definitely on my must-attend list.  The
    people that I met (which could be another couple of blog posts)
    were worth the admission all by themselves.  The talks were
    fascinating and gave me a ton to read up on.  The conference felt
    like it was well-run and organized.  St. Louis was a cool city to
    hang out in (I wish we had the same open-container law in
    Madison!).  I can't wait for next year.

    
- date: 2011-08-16
  title: Madison Ruby Conference
  postbody: >
    I'm going to be attending the [Madison Ruby
    Conference](http://madisonruby.org) this Friday and Saturday.  I
    must confess that I'm not a Ruby-ista (does this reveal my
    *pythonista* heritage?) by training but I'm really excited to go
    and see who attends, chat with smart tech-folk, and generally have
    a good nerd-time yakking about code.  Plus, it couldn't hurt to
    see a little ruby code and see what all the fuss is about.  I'm
    not going to confine myself to: C, Java, Python, Lisp, Haskell,
    and shell. Conference Ahoy.

- date: 2011-07-03
  title: Social Networking
  postbody: >
    *Google+ is another Facebook*.  It may be nice but we should all
    remember that it is basically the same thing.  That may be a
    positive or a negative for you, but the same conversation that
    we've been having about Facebook applies to Google+.  If we want
    to network with people, perhaps it is worthwhile to consider
    existing tools.  Blogs for general sharing (blogs that live on
    your own server!), email for 1-to-1 correspondence, IRC for chat
    and so on.  You don't need a third party to mediate your
    relationships.


    Enjoy the [XKCD on the topic](http://xkcd.com/918/).

- date: 2011-06-21
  title: Code Crawl
  postbody: >
    A *code crawl* is an event that's a mix of a
    [hackathon](http://en.wikipedia.org/wiki/Hackathon) and a [pub
    crawl](http://en.wikipedia.org/wiki/Pub_crawl).  Here's how it
    works:


    Interested parties grab their laptops or, I suppose, lug their
    desktops, out to the bars.  Everybody orders a drink or two and
    hacks on code for around an hour.  The group gathers around a big
    table if the bar has it, or keeps in quasi-remote contact from the
    bar's far-flung corners via IRC or the like.  If the atmosphere
    allows it, it's fun for participants to just yell "try it now" or
    "pull from my repo" across the room.  Maybe they'll get puzzled
    stares from other patrons.  They should just explain that it's a
    code crawl and everyone is programming!  When they reach a good
    *break point* (ha), or just after an hour or two, everybody closes
    out their tabs (or the single mondo-tab!) and heads off to the
    next stop on the crawl.


    Groups can do something fun when they think they've collectively
    hit the [Ballmer Peak](http://xkcd.com/323/).  Of course, it's
    probably then a good time to wrap up the crawl!
    
- date: 2011-05-27
  title: First Post
  postbody: >
    First post.  That's what's the best about reformatting a blog.  It
    always seems to generate at least one extra post.  It's weird how
    blogging software does that.

- date: 2011-05-01
  title: Hackerspace Show on Wisconsin Public Radio
  postbody: >
    [Larry Meiller did a show
    about](http://www.wpr.org/webcasting/audioarchives_display.cfm?Code=mlr&StartRow=1&keyword=makerspace&highlight=on&x=0&y=0)
    (maker|hacker)spaces in Wisconsin. Sector67 is mentioned.

- date: 2011-03-02
  title: "Don't zip, bundle(1)"
  postbody: >
    I've been playing around with Plan 9 from Bell Labs a bunch
    lately. It takes the Unix idea that everything should have a
    file-like interface and runs with that to its logical (and
    surprisingly useful) extreme. It seems like a system that hangs
    together really well and has the feeling that it was actually
    designed, rather than grown. But that's enough about that. What I
    wanted to mention was a script, bundle(1), that I found to be
    really useful. So, use the source, Luke!, and then I'll say
    something about it:

        #!/bin/sh
        echo '# To unbundle, run this file'
        for i
        do
            echo "echo $i"
            echo "sed 's/.//' >$i <<'//GO.SYSIN DD $i'"
            sed "s/^/-/" $i
            echo "//GO.SYSIN DD $i"
        done

    Cool huh? It's kinda meta but here's what it does: when you run it
    like bundle file1 file2 > regen.sh it outputs a script that when
    run will recreate file1 and file2. It does this with a few
    applications of sed. Using file1 and file2 as examples, say I
    have file1's contents:

        hello

    and file2 is:

        world!

    after running bundle with these two files the contents of regen.sh
    will look like this:

        # To unbundle, run this file
        echo file1
        sed 's/.//' > file1 <<'//GO.SYSIN DD file1'
        -hello
        //GO.SYSIN DD file1
        echo file2
        sed 's/.//' > file2 <<'//GO.SYSIN DD file2'
        -world!
        //GO.SYSIN DD file2

    so, if you run this file, it prints "file1" and "file2" to the
    terminal, but then writes "hello" and "world" to file1 and file2,
    respectively (after having stripped the "-" off of each line using
    sed).  So this is a neat little way to package up a bunch of
    text-ish files into a single "self-expanding" package.


- date: 2011-03-20
  title: Learning to type on the Twiddler keyboard
  postbody: >
    I recently got a twiddler chorded keyboard (I love it).  My two
    main goals with it are to be able to use it while doing things
    like giving talks, because it is like having one of those
    presentation clickers yet at the same time being able to
    competently type with it. And the second goal is to use it on my
    smartphone as a better alternative to the on-screen keyboard. I
    just want to make a little aside on the second goal.  It's not
    totally clear to me how to use an external USB keyboard with
    Android (though I have some leads) but things look generally
    promising.


    Either use, of course, assumes that I can type on the crazy
    thing.  I'm one of those people that find it fun to try and
    re-wire my brain to do new things and I figure that if I switched
    to dvorak (and have been using it for about 10 years) that I can
    tackle this thing! I decided to do some drills with the Twiddler
    so that I get to the point where I can use it for day-to-day
    stuff, from then on it'll bootstrap itself through frequent
    use.  That, by the way, was roughly my technique for learning
    dvorak back in the day

     1. Print out the layout and tape it up at eye-level, this breaks
        you of the habit of looking at the keys (they won't help you
        if you remap the keyboard in software)
     2. Do simple drills of the home row (this is great on Dvorak
        because you can form TONS of words)
     3. Expand the drills to less frequently used letters and
        characters
     4. Now that you can type all words, even if you are slow, get on
        IM or IRC in a low-traffic channel that you would like to
        participate in, and just converse. This will provide both
        motivation and practice without the feeling of banging your
        head against the wall.
     5. Do this daily or almost-daily for about 4-8 weeks (that's
        about how long it took me to match and then exceed my QWERTY
        speed)

    To deal with steps 2 and 3 on the twiddler, I wrote this
    short python script that pulls words out out /usr/share/dict/words
    that can be typed without any chord (open), using the first chord
    key (1st or "L"), and finally the second chord key (2nd or
    "M").  I don't have the third chord key on here because using just
    the first and second is sufficient for all letters.  Here's the
    script:

        import random

        def all_from(target_list, input_list):
            for c in input_list:
                if not c in target_list:
                    return False
            return True
        
        def first_set(input_word):
            return all_from("abcdefghABCDEFGH", input_word)
        
        def second_set(input_word):
            return all_from("ijklmnopqIJKLMNOPQ", input_word)
        
        def third_set(input_word):
            return all_from("rstuvwxyzRSTUVWXYZ", input_word)
        
        def fourth_set(input_word):
            return all_from(".,;'\"?!-", input_word)
        
        def search_words(words, key_set=first_set):
            out = []
            for word in words:
                if key_set(word) and len(word) > 1:
                    out.append(word)
            return out
        
        if __name__ == "__main__":
            get_words = 10
            fname = "/usr/share/dict/words"
            wordlist = open(fname, "r").read().split("\n")
        
            first = search_words(wordlist, first_set)
            second = search_words(wordlist, second_set)
            third = search_words(wordlist, third_set)
            #fourth = search_words(wordlist, fourth_set) # need wordlist w/ punct.
        
            print "open: ", " ".join(random.sample(first, get_words))
            print "1st:  ", " ".join(random.sample(second, get_words))
            print "2nd:  ", " ".join(random.sample(third, get_words))
            #print "3rd:  ", " ".join(random.sample(fourth, get_words))

- date: 2010-12-05
  title: unfill-paragraph (only Emacs nerds need apply)
  postbody: >
    I usually keep plain text at a nice and tidy 72 columns (give or
    take, but certainly under 80!).  But there are times when it is
    necessary to have code that will be folded (word-wrapped) by the
    end user.  Think of those text boxes on websites where the result
    is going to be displayed on some website in a totally unformatted
    way. In this case you want the text to be one long line per
    paragraph with a blank line separating each. That way, the text is
    as wide as the browser window or otherwise follows user
    preferences (see
    <http://www.mozilla.org/unix/customizing.html#usercss> for how to
    do this in Firefox). Since I'm always hitting M-q in Emacs, my
    code's always formatted at 72ish columns. The following bit of
    Emacs Lisp lets you unfill-lines, that is it strips out newline
    characters within a paragraph.

        ;; Stefan Monnier <foo at acm.org>. It is the opposite of fill-paragraph
        ;; Takes a multi-line paragraph and makes it into a single line of text.
        
        (defun unfill-paragraph ()
            (interactive)
            (let ((fill-column (point-max)))
            (fill-paragraph nil)))
        
        (global-set-key (kbd "C-c M-q") 'unfill-paragraph)

- date: 2010-11-16
  title: Maine
  postbody: >
    <div class="gallery"><a href="img/DSC-6981-SMALL.jpg"><img 
      alt="Maine Seashore"
      src="img/DSC-6981-SMALL-1024x680.jpg"></a></div>

- date: 2010-11-13
  title: Remembrance of Blogs Past
  postbody: >
    <div class="img"><img src="img/hypnotoad_clockscope.jpg" 
    alt="hypnotoad"></div>
    Yikes, it always seems to come to this. I find myself with a blank
    directory or database (it depends on the blog) that needs to be
    filled up with stuff that I write. And as is the requirement, I go
    and start filling it up with data.


    I can pardon you for missing the blog that previously inhabited
    this domain name. Its short run was punctuated by frequent DNS
    issues, the blog equivalent of being deprived of oxygen. It was
    also overly fussy in its implementation so there was really no
    chance that Sarah would ever put words on the site (the same is
    true for me).


    I switched over to WordPress after seeing some pretty impressive
    examples of what it does nowadays.


    So as has become my custom, I'll link back to other sites that
    I've also written.

     * [chrisblog](chrisblog.zip) (Blogger, zip file)
     * [Nerd Blog](http://twopoint718.posterous.com/) (Posterous)
     * [sencjw_blog](sencjw_blog.zip) (zip file)
